<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>SLAE64 on Andrea Perfetti</title>
    <link>https://andrea-perfetti.github.io/tags/slae64/</link>
    <description>Recent content in SLAE64 on Andrea Perfetti</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Andrea Perfetti</copyright>
    <lastBuildDate>Sun, 11 Apr 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://andrea-perfetti.github.io/tags/slae64/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>SLAE64 - Assignment 4 - Encoder</title>
      <link>https://andrea-perfetti.github.io/posts/slae64-exam/2021-04-11-slae64-assignment-4/</link>
      <pubDate>Sun, 11 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://andrea-perfetti.github.io/posts/slae64-exam/2021-04-11-slae64-assignment-4/</guid>
      <description>The fourth assigment for the SLAE64 certification asks to create a custom encoding scheme like the &amp;ldquo;Insertion Encoder&amp;rdquo; that has been presented in the course. A PoC is also requested, using execve-stack shellcode.
The encoding schema I have decided to go for a mix of the Insertion Encoder and XOR encoder.
Each byte of the shellcode is XOR-ed with a variable key, and after the a garbage \xFE byte is added.</description>
    </item>
    
    <item>
      <title>SLAE64 - Assignment 7 - Crypter</title>
      <link>https://andrea-perfetti.github.io/posts/slae64-exam/2021-04-11-slae64-assignment-7/</link>
      <pubDate>Sun, 11 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://andrea-perfetti.github.io/posts/slae64-exam/2021-04-11-slae64-assignment-7/</guid>
      <description>The seventh assignment for the SLAE64 certification asks to create a custom crypter like the one shown in the &amp;ldquo;Crypters&amp;rdquo; video. You are free to use any existing encryption schema and any programming language.
I have used the same encryption scheme and encrypt tool built for the SLAE32 certification (you can read about it at this link)
Encrypter The encrypter tool:
 takes the shellcode to be encrypted from the shellcode variable creates a salt taking 16 random characters from digits and ascii_uppercase asks the user for the encryption password performs the encryption process prints on screen the different components:  chosen password in plaintext random salt computed encrypted payload, which is a string obtained by concatenating:  the random salt the shellcode encrypted with Fernet      The encrypted payload must be copied into the Decrypt-Exec utility.</description>
    </item>
    
    <item>
      <title>SLAE64 - Assignment 6 - Polymorphism</title>
      <link>https://andrea-perfetti.github.io/posts/slae64-exam/2021-04-10-slae64-assignment-6/</link>
      <pubDate>Sat, 10 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://andrea-perfetti.github.io/posts/slae64-exam/2021-04-10-slae64-assignment-6/</guid>
      <description>The sixth assigment for the SLAE64 certification asks to select 3 shellcodes from Shell-Storm and create a polymorphic version of them in order to beat pattern matching.
The polymorphic version cannot be larger more than 150% of the original shellcode.
For each shellcode, the following steps have been followed:
 Download the shellcode to create Original.nasm Create polymorphic version Polymorphic.nasm Compile both to confirm that the behavior is the same  execve() The first shellcode I have selected is Linux/x86_64 execve.</description>
    </item>
    
    <item>
      <title>SLAE64 - Assignment 1 - TCP Bind Shell with passcode</title>
      <link>https://andrea-perfetti.github.io/posts/slae64-exam/2021-04-05-slae64-assignment-1/</link>
      <pubDate>Mon, 05 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://andrea-perfetti.github.io/posts/slae64-exam/2021-04-05-slae64-assignment-1/</guid>
      <description>The first assigment for the SLAE64 certification asks to write a TCP Bind Shell shellcode that listens on a port and then executes a shell after verifying a &amp;ldquo;passcode&amp;rdquo; on successful connection.
For the basic structure of a Bind Shell TCP, please refer to assignment 5 and to related assignment for the SLAE32 certification.
In order to verify the passcode, a code section has been added after the dup2 cycle, in order to perform a read syscall which puts the 8 bytes read on the stack and compares with the hardcoded passcode (acceptme).</description>
    </item>
    
    <item>
      <title>SLAE64 - Assignment 3 - EggHunter</title>
      <link>https://andrea-perfetti.github.io/posts/slae64-exam/2021-04-05-slae64-assignment-3/</link>
      <pubDate>Mon, 05 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://andrea-perfetti.github.io/posts/slae64-exam/2021-04-05-slae64-assignment-3/</guid>
      <description>The third assigment for the SLAE64 certification asks to study about the EggHunter shellcode and to create a working demo of it.
Egg Hunting (tl;dr) The most basic Buffer Overflow exploit technique consists of creating a string that contains garbage bytes, a memory address to be overwritten on the return address (which will be popped into EIP during the ret procedure) and some shellcode to be then executed, being invoked via a JMP ESP.</description>
    </item>
    
    <item>
      <title>SLAE64 - Assignment 2 - TCP Reverse Shell with passcode</title>
      <link>https://andrea-perfetti.github.io/posts/slae64-exam/2021-04-04-slae64-assignment-2/</link>
      <pubDate>Sun, 04 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://andrea-perfetti.github.io/posts/slae64-exam/2021-04-04-slae64-assignment-2/</guid>
      <description>The second assigment for the SLAE64 certification asks to write a TCP Reverse Shell shellcode that connects to an address and a port and then executes a shell after verifying a &amp;ldquo;passcode&amp;rdquo; on successful connection.
For the basic structure of a Reverse Shell TCP, please refer to assignment 5 and to related assignment for the SLAE32 certification.
In order to verify the passcode, a code section has been added after the dup2 cycle, in order to perform a read syscall which puts the 8 bytes read on the stack and compares with the hardcoded passcode (acceptme).</description>
    </item>
    
    <item>
      <title>SLAE64 - Assignment 5 - Analysis</title>
      <link>https://andrea-perfetti.github.io/posts/slae64-exam/2021-04-04-slae64-assignment-5/</link>
      <pubDate>Sun, 04 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://andrea-perfetti.github.io/posts/slae64-exam/2021-04-04-slae64-assignment-5/</guid>
      <description>The fifth assigment for the SLAE64 certification asks to choose 3 shellcode samples created with Msfpayload for linux/x86_64 and dissect them presenting the analysis.
The list of available shellcodes have been generated using the following command:
┌──(kali㉿kali)-[~/Labs/SLAE64/Assignment-5] └─$ msfvenom --list payloads | grep linux/x64 &amp;gt; List_Payloads_Linux-x64.txt Bind TCP The first shellcode I have selected is linux/x64/shell_bind_tcp.
First of all, we need to understand which parameters this shellcode needs:
┌──(kali㉿kali)-[~/Labs/SLAE64/Assignment-5/5.1-ShellBindTcp] └─$ msfvenom -p linux/x64/shell_bind_tcp --list-options Options for payload/linux/x64/shell_bind_tcp: ========================= Name: Linux Command Shell, Bind TCP Inline Module: payload/linux/x64/shell_bind_tcp Platform: Linux Arch: x64 Needs Admin: No Total size: 86 Rank: Normal Provided by: ricky Basic options: Name Current Setting Required Description ---- --------------- -------- ----------- LPORT 4444 yes The listen port RHOST no The target address Description: Listen for a connection and spawn a command shell For the sake of diversity, I selected port 5555, therefore the shellcode generation is done with the following command:</description>
    </item>
    
  </channel>
</rss>
